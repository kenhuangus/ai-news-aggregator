---
phase: 01-configuration-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - agents/config/migration.py
  - agents/config/__init__.py
  - agents/llm_client.py
autonomous: true

must_haves:
  truths:
    - "User with ANTHROPIC_API_KEY and ANTHROPIC_API_BASE env vars sees auto-generated providers.yaml"
    - "User's .env file is renamed to .env.backup after migration"
    - "User with existing providers.yaml and .env sees warning that .env is ignored"
    - "LLM client can be initialized from ProviderConfig object"
    - "LLM client falls back to env vars only when no config provided (backwards compat during transition)"
  artifacts:
    - path: "agents/config/migration.py"
      provides: "Env var detection and YAML config generation"
      exports: ["migrate_from_env"]
    - path: "agents/config/__init__.py"
      provides: "Updated with migration integration"
      exports: ["load_config", "migrate_from_env"]
    - path: "agents/llm_client.py"
      provides: "Config-based initialization support"
      contains: "from_config"
  key_links:
    - from: "agents/config/migration.py"
      to: "os.environ"
      via: "env var detection"
      pattern: "os\\.environ\\.get"
    - from: "agents/llm_client.py"
      to: "agents/config/schema.py"
      via: "LLMProviderConfig import"
      pattern: "from .config import"
---

<objective>
Create the migration module for auto-converting env vars to YAML config, and update LLM client to accept ProviderConfig for initialization.

Purpose: Enable seamless transition from env var setup to YAML config without breaking existing deployments.
Output: Migration module that auto-generates providers.yaml, LLM client with from_config() class method.
</objective>

<execution_context>
@/Users/ryand/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ryand/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-configuration-infrastructure/01-RESEARCH.md
@.planning/phases/01-configuration-infrastructure/01-CONTEXT.md
@.planning/phases/01-configuration-infrastructure/01-01-SUMMARY.md

# Reference files
@agents/llm_client.py
@agents/config/schema.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration module for env var to YAML conversion</name>
  <files>agents/config/migration.py</files>
  <action>
Create `agents/config/migration.py` that detects existing env vars and generates providers.yaml.

The migration should:
1. Check for ANTHROPIC_API_KEY, ANTHROPIC_API_BASE, ANTHROPIC_MODEL env vars
2. If found, generate providers.yaml with those values
3. Rename .env to .env.backup if it exists
4. Return True if migration happened, False if no env vars found

```python
"""Migration from environment variables to YAML configuration."""
import os
import logging
from pathlib import Path
from datetime import datetime

import yaml

logger = logging.getLogger(__name__)

# Environment variables to detect and migrate
ENV_VAR_MAPPING = {
    # LLM provider
    'ANTHROPIC_API_KEY': ('llm', 'api_key'),
    'ANTHROPIC_API_BASE': ('llm', 'base_url'),
    'ANTHROPIC_MODEL': ('llm', 'model'),
    # Image provider (uses same key in current setup)
    # Note: Image config is optional and not auto-migrated
}


def detect_env_vars() -> dict:
    """
    Detect existing environment variables for provider config.

    Returns:
        Dict with detected config values, or empty dict if none found
    """
    config = {'llm': {}}
    found_any = False

    for env_var, (section, key) in ENV_VAR_MAPPING.items():
        value = os.environ.get(env_var)
        if value:
            config[section][key] = value
            found_any = True
            logger.debug(f"Detected {env_var}")

    # Remove empty sections
    if not config['llm']:
        del config['llm']

    return config if found_any else {}


def migrate_from_env(config_dir: str) -> bool:
    """
    Migrate from environment variables to YAML configuration.

    Creates providers.yaml from detected env vars and backs up .env.

    Args:
        config_dir: Directory to write providers.yaml

    Returns:
        True if migration was performed, False if no env vars detected
    """
    config_path = Path(config_dir) / "providers.yaml"
    env_path = Path(config_dir).parent / ".env"  # .env is typically in project root

    # Don't overwrite existing config
    if config_path.exists():
        if env_path.exists():
            logger.warning(
                f"Both {config_path} and .env exist. "
                f"Using {config_path}, .env settings are ignored."
            )
        return True  # Config exists, no migration needed

    # Detect env vars
    detected = detect_env_vars()
    if not detected:
        logger.debug("No provider environment variables detected")
        return False

    # Validate we have minimum required config
    if 'llm' not in detected or 'api_key' not in detected.get('llm', {}):
        logger.warning("ANTHROPIC_API_KEY not found, cannot migrate")
        return False

    if 'base_url' not in detected.get('llm', {}):
        logger.warning("ANTHROPIC_API_BASE not found, cannot migrate")
        return False

    # Add defaults for optional fields
    if 'model' not in detected['llm']:
        detected['llm']['model'] = 'claude-opus-4-5-20251101'
    detected['llm']['timeout'] = 300

    # Write YAML config
    config_path.parent.mkdir(parents=True, exist_ok=True)

    yaml_content = f"""# Provider Configuration for AI News Aggregator
# Auto-generated from environment variables on {datetime.now().isoformat()}
# See providers.yaml.example for all options

# LLM Provider (required)
llm:
  api_key: "{detected['llm']['api_key']}"
  base_url: "{detected['llm']['base_url']}"
  model: "{detected['llm']['model']}"
  timeout: {detected['llm']['timeout']}

# Image Provider (optional - hero image generation)
# Uncomment and configure to enable hero images
# image:
#   api_key: "your-image-api-key"
#   endpoint: "https://generativelanguage.googleapis.com/v1beta"
#   model: "gemini-2.0-flash-exp-image-generation"
"""

    with open(config_path, 'w', encoding='utf-8') as f:
        f.write(yaml_content)

    logger.info(f"Created {config_path} from environment variables")

    # Backup .env if it exists
    if env_path.exists():
        backup_path = env_path.with_suffix('.env.backup')
        # Don't overwrite existing backup
        if backup_path.exists():
            backup_path = env_path.with_suffix(f'.env.backup.{datetime.now().strftime("%Y%m%d%H%M%S")}')
        env_path.rename(backup_path)
        logger.info(f"Backed up {env_path} to {backup_path}")

    return True
```
  </action>
  <verify>
```bash
cd /Users/ryand/Code/AATF/ai-news-aggregator
python3 -c "from agents.config.migration import migrate_from_env, detect_env_vars; print('Migration module: OK')"
```
  </verify>
  <done>Migration module detects env vars and generates providers.yaml with .env backup</done>
</task>

<task type="auto">
  <name>Task 2: Update config __init__.py to integrate migration</name>
  <files>agents/config/__init__.py</files>
  <action>
Update `agents/config/__init__.py` to:
1. Export migrate_from_env
2. Use migration as default when calling load_config without migrate_fn
3. Add convenience function for getting config with auto-migration

```python
"""Provider configuration module."""
import logging
import sys
from pathlib import Path
from typing import Optional

from pydantic import ValidationError

from .schema import ProviderConfig, LLMProviderConfig, ImageProviderConfig
from .loader import load_yaml_with_env, EnvVarError
from .migration import migrate_from_env, detect_env_vars

__all__ = [
    'load_config',
    'ProviderConfig',
    'LLMProviderConfig',
    'ImageProviderConfig',
    'migrate_from_env',
]

logger = logging.getLogger(__name__)


def load_config(config_dir: str, auto_migrate: bool = True) -> ProviderConfig:
    """
    Load and validate provider configuration.

    Args:
        config_dir: Directory containing providers.yaml
        auto_migrate: If True, attempt to migrate from env vars if no config exists

    Returns:
        Validated ProviderConfig

    Raises:
        SystemExit: If config is missing or invalid (with helpful error message)
    """
    config_path = Path(config_dir) / "providers.yaml"
    example_path = Path(config_dir) / "providers.yaml.example"

    # Check if config exists
    if not config_path.exists():
        if auto_migrate:
            try:
                if migrate_from_env(config_dir):
                    logger.info(f"Migrated environment variables to {config_path}")
                else:
                    _exit_with_config_instructions(config_path, example_path)
            except Exception as e:
                logger.error(f"Migration failed: {e}")
                _exit_with_config_instructions(config_path, example_path)
        else:
            _exit_with_config_instructions(config_path, example_path)

    # Warn if .env exists alongside providers.yaml
    env_path = Path(config_dir).parent / ".env"
    if config_path.exists() and env_path.exists():
        logger.warning(
            f"Both providers.yaml and .env exist. "
            f"Using providers.yaml, environment variables in .env are ignored for provider settings."
        )

    # Load YAML with env var interpolation
    try:
        raw_config = load_yaml_with_env(config_path)
    except EnvVarError as e:
        logger.error(f"Configuration error: {e}")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Failed to load {config_path}: {e}")
        sys.exit(1)

    # Check for unrecognized top-level keys
    known_keys = {'llm', 'image'}
    unknown_keys = set(raw_config.keys()) - known_keys
    if unknown_keys:
        logger.warning(f"Unrecognized config keys (ignored): {', '.join(unknown_keys)}")

    # Validate with Pydantic
    try:
        config = ProviderConfig.model_validate(raw_config)
        logger.info(f"Loaded provider config: llm.model={config.llm.model}, "
                   f"image={'enabled' if config.image else 'disabled'}")
        return config
    except ValidationError as e:
        logger.error("Configuration validation failed:")
        for err in e.errors():
            loc = '.'.join(str(l) for l in err['loc'])
            msg = err['msg']
            logger.error(f"  {loc}: {msg}")
        sys.exit(1)


def _exit_with_config_instructions(config_path: Path, example_path: Path):
    """Exit with helpful instructions for creating config."""
    logger.error(f"Configuration file not found: {config_path}")
    if example_path.exists():
        logger.error(f"  Copy the example: cp {example_path} {config_path}")
    else:
        logger.error(f"  Create {config_path} with LLM provider settings")
    logger.error("  See documentation for configuration options")
    sys.exit(1)
```
  </action>
  <verify>
```bash
cd /Users/ryand/Code/AATF/ai-news-aggregator
python3 -c "from agents.config import load_config, migrate_from_env; print('Config with migration: OK')"
```
  </verify>
  <done>load_config() integrates auto-migration, warns when .env coexists with providers.yaml</done>
</task>

<task type="auto">
  <name>Task 3: Update LLM client to support config-based initialization</name>
  <files>agents/llm_client.py</files>
  <action>
Update `agents/llm_client.py` to add `from_config()` class method that creates client from ProviderConfig.

Add to both `AnthropicClient` and `AsyncAnthropicClient`:

1. Add import at top of file:
```python
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .config import LLMProviderConfig
```

2. Add class method to `AnthropicClient` (after `__init__`):
```python
@classmethod
def from_config(cls, config: 'LLMProviderConfig') -> 'AnthropicClient':
    """
    Create client from LLMProviderConfig.

    Args:
        config: LLMProviderConfig with api_key, base_url, model, timeout

    Returns:
        Configured AnthropicClient instance
    """
    return cls(
        api_key=config.api_key,
        base_url=config.base_url,
        model=config.model,
        timeout=config.timeout
    )
```

3. Add same class method to `AsyncAnthropicClient`:
```python
@classmethod
def from_config(cls, config: 'LLMProviderConfig') -> 'AsyncAnthropicClient':
    """
    Create client from LLMProviderConfig.

    Args:
        config: LLMProviderConfig with api_key, base_url, model, timeout

    Returns:
        Configured AsyncAnthropicClient instance
    """
    return cls(
        api_key=config.api_key,
        base_url=config.base_url,
        model=config.model,
        timeout=config.timeout
    )
```

The existing `__init__` methods still support direct parameters and env var fallbacks for backwards compatibility during the transition period. The orchestrator will be updated in Plan 03 to use `from_config()`.
  </action>
  <verify>
```bash
cd /Users/ryand/Code/AATF/ai-news-aggregator
python3 -c "
from agents.llm_client import AnthropicClient, AsyncAnthropicClient
from agents.config.schema import LLMProviderConfig

# Verify from_config exists
assert hasattr(AnthropicClient, 'from_config'), 'AnthropicClient.from_config'
assert hasattr(AsyncAnthropicClient, 'from_config'), 'AsyncAnthropicClient.from_config'

# Test from_config (without actually connecting)
config = LLMProviderConfig(
    api_key='test-key',
    base_url='https://api.anthropic.com',
    model='claude-sonnet-4-20250514',
    timeout=120.0
)

# This will fail to connect but proves the method works
try:
    client = AnthropicClient.from_config(config)
    print(f'AnthropicClient.from_config: OK (model={client.model})')
    client.close()
except Exception as e:
    # Connection errors are fine, we're just testing the config parsing
    if 'test-key' in str(e) or 'API' in str(e):
        print('AnthropicClient.from_config: OK (expected auth error)')
    else:
        raise
"
```
  </verify>
  <done>LLM clients have from_config() class method for ProviderConfig-based initialization</done>
</task>

</tasks>

<verification>
```bash
cd /Users/ryand/Code/AATF/ai-news-aggregator

# 1. Verify migration module
python3 -c "
from agents.config.migration import migrate_from_env, detect_env_vars
import os

# Test detection with no env vars
result = detect_env_vars()
assert result == {}, 'No env vars detected when none set'
print('detect_env_vars (empty): OK')

# Test detection with env vars
os.environ['ANTHROPIC_API_KEY'] = 'test-key'
os.environ['ANTHROPIC_API_BASE'] = 'https://test.api'
result = detect_env_vars()
assert result['llm']['api_key'] == 'test-key', 'API key detected'
assert result['llm']['base_url'] == 'https://test.api', 'Base URL detected'
print('detect_env_vars (populated): OK')

# Cleanup
del os.environ['ANTHROPIC_API_KEY']
del os.environ['ANTHROPIC_API_BASE']
"

# 2. Verify load_config exports migration
python3 -c "
from agents.config import load_config, migrate_from_env, ProviderConfig
print('Config exports: OK')
"

# 3. Verify LLM client from_config
python3 -c "
from agents.llm_client import AnthropicClient, AsyncAnthropicClient
from agents.config.schema import LLMProviderConfig

config = LLMProviderConfig(
    api_key='sk-test-123',
    base_url='https://api.anthropic.com',
    model='claude-opus-4-5-20251101',
    timeout=300.0
)

# Test AnthropicClient.from_config
client = AnthropicClient.from_config(config)
assert client.api_key == 'sk-test-123', 'API key passed'
assert client.base_url == 'https://api.anthropic.com', 'Base URL passed'
assert client.model == 'claude-opus-4-5-20251101', 'Model passed'
assert client.timeout == 300.0, 'Timeout passed'
client.close()
print('AnthropicClient.from_config: OK')
"

# 4. Verify warning when both config and .env exist
python3 -c "
import tempfile
import os
from pathlib import Path

# This test would need actual files, just verify the code path exists
from agents.config import load_config
import inspect
source = inspect.getsource(load_config)
assert '.env exist' in source or 'env_path.exists()' in source, 'Warning logic present'
print('Dual config warning: OK')
"

echo "All verifications passed"
```
</verification>

<success_criteria>
- agents/config/migration.py detects ANTHROPIC_* env vars and generates YAML
- migrate_from_env() backs up .env to .env.backup
- load_config() auto-migrates when no providers.yaml exists
- load_config() warns when both providers.yaml and .env exist
- AnthropicClient.from_config() creates client from LLMProviderConfig
- AsyncAnthropicClient.from_config() creates client from LLMProviderConfig
- All verification commands pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-configuration-infrastructure/01-02-SUMMARY.md`
</output>
