---
phase: 01-configuration-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - agents/config/__init__.py
  - agents/config/schema.py
  - agents/config/loader.py
  - config/providers.yaml.example
autonomous: true

must_haves:
  truths:
    - "Pydantic schema validates LLM provider config with api_key, base_url, model, timeout fields"
    - "Pydantic schema validates optional Image provider config with api_key, endpoint, model fields"
    - "YAML loader resolves ${VAR} patterns from environment variables"
    - "YAML loader raises clear error when referenced env var is missing"
    - "Example file documents all configuration options with comments"
  artifacts:
    - path: "agents/config/schema.py"
      provides: "Pydantic models for ProviderConfig, LLMProviderConfig, ImageProviderConfig"
      exports: ["ProviderConfig", "LLMProviderConfig", "ImageProviderConfig"]
    - path: "agents/config/loader.py"
      provides: "YAML loading with ${VAR} interpolation"
      exports: ["load_yaml_with_env"]
    - path: "agents/config/__init__.py"
      provides: "Public API for config module"
      exports: ["load_config", "ProviderConfig"]
    - path: "config/providers.yaml.example"
      provides: "User-facing configuration template"
      contains: "llm:"
  key_links:
    - from: "agents/config/loader.py"
      to: "os.environ"
      via: "${VAR} pattern resolution"
      pattern: "os\\.environ\\.get"
    - from: "agents/config/__init__.py"
      to: "agents/config/schema.py"
      via: "model import"
      pattern: "from .schema import"
---

<objective>
Create the foundational configuration infrastructure: Pydantic schema for provider config validation and YAML loader with environment variable interpolation.

Purpose: Establish type-safe configuration system that validates user config at startup and provides clear error messages.
Output: `agents/config/` module with schema and loader, plus updated example file.
</objective>

<execution_context>
@/Users/ryand/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ryand/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-configuration-infrastructure/01-RESEARCH.md
@.planning/phases/01-configuration-infrastructure/01-CONTEXT.md

# Existing files for reference
@agents/__init__.py
@config/providers.yaml.example
@requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic schema for provider configuration</name>
  <files>agents/config/__init__.py, agents/config/schema.py</files>
  <action>
Create `agents/config/` directory with `__init__.py` and `schema.py`.

In `schema.py`, define Pydantic v2 models:

```python
from pydantic import BaseModel, Field, field_validator
from typing import Optional

class LLMProviderConfig(BaseModel):
    """Configuration for LLM provider."""
    api_key: str = Field(..., description="API key for authentication")
    base_url: str = Field(..., description="API base URL (no /v1 suffix)")
    model: str = Field(default="claude-opus-4-5-20251101", description="Model identifier")
    timeout: float = Field(default=300.0, ge=1.0, le=600.0, description="Request timeout in seconds")

    @field_validator('api_key')
    @classmethod
    def validate_api_key(cls, v):
        if not v or v == "your-api-key-here":
            raise ValueError("API key not configured. Set a valid key in config/providers.yaml")
        if v.startswith('${') and v.endswith('}'):
            raise ValueError(f"Environment variable {v} was not resolved. Check that the variable is set.")
        return v

    @field_validator('base_url')
    @classmethod
    def validate_base_url(cls, v):
        if v.endswith('/v1'):
            raise ValueError(f"base_url should not include '/v1' suffix. Use '{v[:-3]}' instead.")
        return v

class ImageProviderConfig(BaseModel):
    """Configuration for image generation provider (optional)."""
    api_key: str = Field(..., description="API key for image generation")
    endpoint: str = Field(..., description="API endpoint URL")
    model: str = Field(default="gemini-2.0-flash-exp-image-generation", description="Image model name")

    @field_validator('api_key')
    @classmethod
    def validate_api_key(cls, v):
        if not v or v == "your-image-api-key":
            raise ValueError("Image API key not configured. Set a valid key or remove image section.")
        if v.startswith('${') and v.endswith('}'):
            raise ValueError(f"Environment variable {v} was not resolved. Check that the variable is set.")
        return v

class ProviderConfig(BaseModel):
    """Root configuration schema for all providers."""
    llm: LLMProviderConfig
    image: Optional[ImageProviderConfig] = None

    model_config = {"extra": "ignore"}  # Warn but don't error on unknown keys
```

In `__init__.py`, export public API (placeholder for now, will complete in Task 3):
```python
"""Provider configuration module."""
from .schema import ProviderConfig, LLMProviderConfig, ImageProviderConfig

__all__ = ['ProviderConfig', 'LLMProviderConfig', 'ImageProviderConfig']
```
  </action>
  <verify>
```bash
cd /Users/ryand/Code/AATF/ai-news-aggregator
python3 -c "from agents.config import ProviderConfig, LLMProviderConfig; print('Schema imports OK')"
```
  </verify>
  <done>Pydantic schema classes defined and importable from agents.config</done>
</task>

<task type="auto">
  <name>Task 2: Create YAML loader with environment variable interpolation</name>
  <files>agents/config/loader.py</files>
  <action>
Create `agents/config/loader.py` with custom YAML loader that resolves `${VAR}` patterns.

```python
"""YAML loader with environment variable interpolation."""
import os
import re
import logging
from pathlib import Path
from typing import Any, Dict

import yaml

logger = logging.getLogger(__name__)

# Pattern to match ${VAR_NAME} in strings
ENV_VAR_PATTERN = re.compile(r'\$\{([A-Za-z_][A-Za-z0-9_]*)\}')


class EnvVarError(Exception):
    """Raised when an environment variable is not set."""
    pass


def _resolve_env_vars(value: Any, path: str = "") -> Any:
    """
    Recursively resolve ${VAR} patterns in YAML values.

    Args:
        value: The value to process (string, dict, list, or other)
        path: Current path in config for error messages

    Returns:
        Value with environment variables resolved

    Raises:
        EnvVarError: If a referenced environment variable is not set
    """
    if isinstance(value, str):
        matches = ENV_VAR_PATTERN.findall(value)
        if not matches:
            return value

        result = value
        for var_name in matches:
            env_value = os.environ.get(var_name)
            if env_value is None:
                raise EnvVarError(
                    f"Environment variable '{var_name}' not set "
                    f"(referenced in {path or 'config'})"
                )
            result = result.replace(f'${{{var_name}}}', env_value)
        return result

    elif isinstance(value, dict):
        return {
            k: _resolve_env_vars(v, f"{path}.{k}" if path else k)
            for k, v in value.items()
        }

    elif isinstance(value, list):
        return [
            _resolve_env_vars(item, f"{path}[{i}]")
            for i, item in enumerate(value)
        ]

    return value


def load_yaml_with_env(path: Path) -> Dict[str, Any]:
    """
    Load YAML file with ${VAR} environment variable interpolation.

    Args:
        path: Path to YAML file

    Returns:
        Parsed YAML dict with env vars resolved

    Raises:
        FileNotFoundError: If file doesn't exist
        yaml.YAMLError: If YAML is malformed
        EnvVarError: If referenced env var is not set
    """
    with open(path, 'r', encoding='utf-8') as f:
        raw_config = yaml.safe_load(f)

    if raw_config is None:
        return {}

    return _resolve_env_vars(raw_config)
```
  </action>
  <verify>
```bash
cd /Users/ryand/Code/AATF/ai-news-aggregator
# Test basic YAML loading
python3 -c "
from agents.config.loader import load_yaml_with_env, EnvVarError
from pathlib import Path
print('Loader imports OK')
"
```
  </verify>
  <done>YAML loader with ${VAR} interpolation and clear error messages for missing env vars</done>
</task>

<task type="auto">
  <name>Task 3: Update __init__.py with load_config function and verify providers.yaml.example</name>
  <files>agents/config/__init__.py, config/providers.yaml.example</files>
  <action>
Update `agents/config/__init__.py` to include `load_config()` function that ties schema and loader together.

The function should:
1. Check if providers.yaml exists
2. If not, call migration (implemented in Plan 02) or fail with helpful message
3. Load YAML with env var interpolation
4. Validate with Pydantic and return ProviderConfig
5. Log warnings for unrecognized keys

```python
"""Provider configuration module."""
import logging
import sys
from pathlib import Path
from typing import Optional

from pydantic import ValidationError

from .schema import ProviderConfig, LLMProviderConfig, ImageProviderConfig
from .loader import load_yaml_with_env, EnvVarError

__all__ = ['load_config', 'ProviderConfig', 'LLMProviderConfig', 'ImageProviderConfig']

logger = logging.getLogger(__name__)


def load_config(config_dir: str, migrate_fn: Optional[callable] = None) -> ProviderConfig:
    """
    Load and validate provider configuration.

    Args:
        config_dir: Directory containing providers.yaml
        migrate_fn: Optional migration function to call if no config exists.
                    Signature: migrate_fn(config_dir: str) -> bool

    Returns:
        Validated ProviderConfig

    Raises:
        SystemExit: If config is missing or invalid (with helpful error message)
    """
    config_path = Path(config_dir) / "providers.yaml"
    example_path = Path(config_dir) / "providers.yaml.example"

    # Check if config exists
    if not config_path.exists():
        # Try migration if function provided
        if migrate_fn is not None:
            try:
                if migrate_fn(config_dir):
                    logger.info(f"Migrated environment variables to {config_path}")
                else:
                    _exit_with_config_instructions(config_path, example_path)
            except Exception as e:
                logger.error(f"Migration failed: {e}")
                _exit_with_config_instructions(config_path, example_path)
        else:
            _exit_with_config_instructions(config_path, example_path)

    # Load YAML with env var interpolation
    try:
        raw_config = load_yaml_with_env(config_path)
    except EnvVarError as e:
        logger.error(f"Configuration error: {e}")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Failed to load {config_path}: {e}")
        sys.exit(1)

    # Check for unrecognized top-level keys
    known_keys = {'llm', 'image'}
    unknown_keys = set(raw_config.keys()) - known_keys
    if unknown_keys:
        logger.warning(f"Unrecognized config keys (ignored): {', '.join(unknown_keys)}")

    # Validate with Pydantic
    try:
        config = ProviderConfig.model_validate(raw_config)
        logger.info(f"Loaded provider config: llm.model={config.llm.model}, "
                   f"image={'enabled' if config.image else 'disabled'}")
        return config
    except ValidationError as e:
        logger.error("Configuration validation failed:")
        for err in e.errors():
            loc = '.'.join(str(l) for l in err['loc'])
            msg = err['msg']
            logger.error(f"  {loc}: {msg}")
        sys.exit(1)


def _exit_with_config_instructions(config_path: Path, example_path: Path):
    """Exit with helpful instructions for creating config."""
    logger.error(f"Configuration file not found: {config_path}")
    if example_path.exists():
        logger.error(f"  Copy the example: cp {example_path} {config_path}")
    else:
        logger.error(f"  Create {config_path} with LLM provider settings")
    logger.error("  See documentation for configuration options")
    sys.exit(1)
```

Verify `config/providers.yaml.example` is up to date (it already exists and looks good based on earlier read). No changes needed - the example file already documents:
- LLM config: api_key, base_url, model, timeout
- Image config: api_key, endpoint, model (commented out)
- Environment variable interpolation syntax
  </action>
  <verify>
```bash
cd /Users/ryand/Code/AATF/ai-news-aggregator
# Test full config loading flow (will fail without config, but should show helpful error)
python3 -c "
from agents.config import load_config, ProviderConfig
import sys
# Redirect stderr to capture error
import io
old_stderr = sys.stderr
sys.stderr = io.StringIO()
try:
    config = load_config('./config')
except SystemExit as e:
    output = sys.stderr.getvalue()
    sys.stderr = old_stderr
    if 'Configuration file not found' in output or 'providers.yaml' in output:
        print('Config loading with helpful error: OK')
    else:
        print(f'Unexpected error: {output}')
"
```
  </verify>
  <done>load_config() function validates config at startup with clear error messages</done>
</task>

</tasks>

<verification>
```bash
cd /Users/ryand/Code/AATF/ai-news-aggregator

# 1. Verify schema imports
python3 -c "from agents.config import ProviderConfig, LLMProviderConfig, ImageProviderConfig; print('Schema: OK')"

# 2. Verify loader imports
python3 -c "from agents.config.loader import load_yaml_with_env, EnvVarError; print('Loader: OK')"

# 3. Verify load_config function exists
python3 -c "from agents.config import load_config; print('load_config: OK')"

# 4. Test schema validation
python3 -c "
from agents.config.schema import LLMProviderConfig
from pydantic import ValidationError

# Valid config
cfg = LLMProviderConfig(api_key='sk-test', base_url='https://api.anthropic.com')
assert cfg.model == 'claude-opus-4-5-20251101', 'Default model'
assert cfg.timeout == 300.0, 'Default timeout'
print('Schema validation: OK')

# Invalid: placeholder api_key
try:
    LLMProviderConfig(api_key='your-api-key-here', base_url='https://api.anthropic.com')
    print('ERROR: Should reject placeholder')
except ValidationError:
    print('Placeholder rejection: OK')

# Invalid: base_url with /v1 suffix
try:
    LLMProviderConfig(api_key='sk-test', base_url='https://api.anthropic.com/v1')
    print('ERROR: Should reject /v1 suffix')
except ValidationError:
    print('/v1 suffix rejection: OK')
"

# 5. Test env var interpolation
python3 -c "
import os
from agents.config.loader import _resolve_env_vars, EnvVarError

os.environ['TEST_KEY'] = 'secret123'
result = _resolve_env_vars({'api_key': '\${TEST_KEY}'})
assert result['api_key'] == 'secret123', 'Env var resolved'
print('Env var interpolation: OK')

# Missing env var
try:
    _resolve_env_vars({'api_key': '\${MISSING_VAR}'})
    print('ERROR: Should raise for missing var')
except EnvVarError as e:
    assert 'MISSING_VAR' in str(e), 'Error mentions var name'
    print('Missing var error: OK')
"

# 6. Verify example file exists and has correct structure
python3 -c "
import yaml
from pathlib import Path

example = Path('config/providers.yaml.example')
assert example.exists(), 'Example file exists'

with open(example) as f:
    content = yaml.safe_load(f)

assert 'llm' in content, 'Has llm section'
assert 'api_key' in content['llm'], 'Has api_key'
assert 'base_url' in content['llm'], 'Has base_url'
print('Example file structure: OK')
"

echo "All verifications passed"
```
</verification>

<success_criteria>
- agents/config/ module exists with schema.py, loader.py, __init__.py
- ProviderConfig, LLMProviderConfig, ImageProviderConfig Pydantic models defined
- load_yaml_with_env() resolves ${VAR} patterns from environment
- load_config() validates config at startup with clear multi-error output
- config/providers.yaml.example documents all options
- All verification commands pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-configuration-infrastructure/01-01-SUMMARY.md`
</output>
